---
const { lang } = Astro.props;

const linesPL = [
  "$ rocketdeploy deploy system-core --region eu",
  "✓ build",
  "✓ tests",
  "✓ migrate",
  "✓ rollout",
  "→ monitoring: ok",
];

const linesEN = [
  "$ rocketdeploy deploy system-core --region eu",
  "✓ build",
  "✓ tests",
  "✓ migrate",
  "✓ rollout",
  "→ monitoring: ok",
];

const lines = lang === "pl" ? linesPL : linesEN;

// wysokość linii w terminalu (em)
const TERM_LINE_HEIGHT = 1.6;

// bufor na rounding/font metrics (żeby nie ucinało ostatniej linii)
const TERM_HEIGHT_BUFFER_EM = 0.25;
---

<div class="card" style="padding: 14px 14px 12px;">
  <div style="display:flex; gap:8px; align-items:center; margin-bottom: 10px;">
    <span style="width:10px;height:10px;border-radius:999px;background:rgba(255,95,86,.9)"></span>
    <span style="width:10px;height:10px;border-radius:999px;background:rgba(255,189,46,.9)"></span>
    <span style="width:10px;height:10px;border-radius:999px;background:rgba(39,201,63,.9)"></span>
    <span style="margin-left:8px; color: rgba(255,255,255,.5); font-family: var(--mono); font-size: 12px;">
      deploy.log
    </span>
  </div>

  <pre
    id="term"
    style={`
      --term-lines: ${lines.length + 1};
      --term-lh: ${TERM_LINE_HEIGHT};
      --term-buf: ${TERM_HEIGHT_BUFFER_EM};

      margin:0;
      font-family: var(--mono);
      font-size: 13px;
      color: rgba(255,255,255,.78);
      white-space: pre-wrap;

      line-height: var(--term-lh);

      /* STAŁA wysokość od razu (SSR), z buforem na rounding */
      min-height: calc((var(--term-lines) * var(--term-lh) + var(--term-buf)) * 1em);
      max-height: calc((var(--term-lines) * var(--term-lh) + var(--term-buf)) * 1em);

      overflow: hidden;
    `}
  ></pre>

  <script define:vars={{ termLines: lines }}>
    const el = document.getElementById("term");

    const reduce =
      window.matchMedia &&
      window.matchMedia("(prefers-reduced-motion: reduce)").matches;

    let started = false;

    const renderAll = () => {
      el.textContent = termLines.join("\n");
    };

    const startTyping = () => {
      if (started) return;
      started = true;

      if (reduce) return renderAll();

      let i = 0;
      let out = "";

      const tick = () => {
        out += (i === 0 ? "" : "\n") + termLines[i];
        el.textContent = out;
        i++;
        if (i < termLines.length) setTimeout(tick, i === 1 ? 650 : 420);
      };

      setTimeout(tick, 220);
    };

    const isInViewportNow = () => {
      const r = el.getBoundingClientRect();
      return r.top < window.innerHeight && r.bottom > 0;
    };

    if (isInViewportNow()) {
      startTyping();
    } else if ("IntersectionObserver" in window) {
      const io = new IntersectionObserver(
        (entries) => {
          const entry = entries[0];
          if (entry?.isIntersecting) {
            startTyping();
            io.disconnect();
          }
        },
        { threshold: 0.2, rootMargin: "120px 0px" }
      );

      io.observe(el);
    } else {
      const onScroll = () => {
        if (isInViewportNow()) {
          startTyping();
          window.removeEventListener("scroll", onScroll);
        }
      };
      window.addEventListener("scroll", onScroll, { passive: true });
    }
  </script>
</div>